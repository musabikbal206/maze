<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mazemazing 3D Pro</title>
    
    <!-- PWA Settings -->
    <meta name="theme-color" content="#020617">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Phosphor Icons -->
    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <style>
        /* Core Reset */
        body, html { margin: 0; padding: 0; overflow: hidden; background-color: #020617; touch-action: none; font-family: 'Segoe UI', system-ui, sans-serif; height: 100%; width: 100%; user-select: none; -webkit-user-select: none; }
        
        /* Game Layer */
        #game-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        canvas { display: block; width: 100%; height: 100%; outline: none; }
        
        /* UI Screens */
        .ui-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20; display: flex; flex-direction: column; }
        .interactive { pointer-events: auto; }
        .hidden { display: none !important; }

        /* Minimap */
        #minimap-wrapper {
            width: 240px; height: 240px; 
            background: rgba(15, 23, 42, 0.9);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            overflow: hidden;
            display: none;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            margin-top: 10px;
        }

        /* Timer */
        #game-timer {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 8px 16px;
            border-radius: 99px;
            font-family: monospace;
            font-size: 1.5rem;
            font-weight: bold;
            color: #22d3ee;
            z-index: 30;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        /* Controls */
        #controls-ui { display: none; width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 50; pointer-events: none; }
        
        .stick-zone {
            position: absolute; bottom: 40px; left: 40px; 
            width: 140px; height: 140px;
            pointer-events: auto;
        }

        .stick-base {
            width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            position: relative;
            backdrop-filter: blur(4px);
            transition: border-color 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        
        .stick-thumb {
            width: 60px; height: 60px;
            background: radial-gradient(circle at 30% 30%, #22d3ee, #0891b2);
            border-radius: 50%;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 15px rgba(8, 145, 178, 0.5);
            pointer-events: none;
            transition: transform 0.05s linear;
        }

        /* Editor */
        .grid-cell { box-sizing: border-box; border: 1px solid rgba(255,255,255,0.05); cursor: pointer; }
        .c-wall { background: #475569; }
        .c-path { background: #0f172a; }
        .c-start { background: #10b981; }
        .c-end { background: #ef4444; }

        #editor-viewport { overflow: auto; touch-action: pan-x pan-y; cursor: grab; }
        #editor-viewport.mode-draw { touch-action: none; cursor: crosshair; }
        #editor-grid { display: grid; box-shadow: 0 20px 50px rgba(0,0,0,0.8); margin: auto; transform-origin: center; }
        
        /* Technical Background Pattern for Editor */
        .bg-grid-pattern {
            background-color: #020617;
            background-image: radial-gradient(rgba(51, 65, 85, 0.4) 1px, transparent 1px);
            background-size: 24px 24px;
        }

        @keyframes glow {
            0% { box-shadow: 0 0 5px rgba(34, 211, 238, 0.2); }
            50% { box-shadow: 0 0 20px rgba(34, 211, 238, 0.6); }
            100% { box-shadow: 0 0 5px rgba(34, 211, 238, 0.2); }
        }
        .input-glow:focus { animation: glow 2s infinite; }
        
        /* Mobile specific adjustments */
        @media (max-width: 768px) {
            #minimap-wrapper { width: 160px; height: 160px; }
            .btn-game-ui span { display: none; }
            .btn-game-ui { padding: 8px 12px; }
            #ui-code-display { font-size: 0.65rem; padding: 4px 8px; }
        }
        
        /* Keyboard Badge */
        .key-badge {
            background: rgba(255,255,255,0.1);
            padding: 0px 6px;
            border-radius: 4px;
            font-size: 0.7em;
            margin-left: 6px;
            border: 1px solid rgba(255,255,255,0.2);
            color: #94a3b8;
        }
        
        /* Menu Focus Ring for Keyboard Navigation */
        .menu-focus {
            outline: 2px solid #22d3ee;
            outline-offset: 2px;
            transform: scale(1.02);
            background-color: rgb(30 41 59) !important; /* slate-800 */
        }
        
        /* Custom Scrollbar for editor panel */
        .custom-scroll::-webkit-scrollbar { width: 6px; }
        .custom-scroll::-webkit-scrollbar-track { background: #0f172a; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #334155; border-radius: 3px; }
        .custom-scroll::-webkit-scrollbar-thumb:hover { background: #475569; }
    </style>
</head>
<body>

    <!-- Game Layer -->
    <div id="game-layer">
        <canvas id="c3d"></canvas>
        <canvas id="c2d" style="display:none; background:#020617;"></canvas>
    </div>

    <!-- Timer -->
    <div id="game-timer">00:00</div>

    <!-- Joystick (Game Only) -->
    <div id="controls-ui">
        <div class="stick-zone" id="stick-zone">
            <div class="stick-base">
                <div class="stick-thumb" id="stick-thumb"></div>
            </div>
            <div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 pointer-events-none opacity-30 text-white text-2xl">
                <i class="ph ph-arrows-out-cardinal"></i>
            </div>
        </div>
    </div>

    <!-- Desktop Hint -->
    <div id="controls-hint" class="ui-screen hidden md:flex justify-end items-end p-8 z-10 pointer-events-none">
        <div class="bg-slate-900/80 backdrop-blur p-4 rounded-xl border border-white/10 text-slate-400 text-sm font-mono flex flex-col gap-2">
            <div class="flex items-center gap-4"><span class="bg-slate-700 px-2 rounded text-white">WASD</span> <span data-i18n="hint_move">Move</span></div>
            <div class="flex items-center gap-4"><span class="bg-slate-700 px-2 rounded text-white">M</span> <span data-i18n="hint_map">Map</span></div>
            <div class="flex items-center gap-4"><span class="bg-slate-700 px-2 rounded text-white">V</span> <span data-i18n="hint_view">View</span></div>
            <div class="flex items-center gap-4"><span class="bg-slate-700 px-2 rounded text-white">ESC</span> <span data-i18n="main_menu">Main Menu</span></div>
        </div>
    </div>

    <!-- Main Menu -->
    <div id="screen-menu" class="ui-screen interactive bg-slate-950/95 flex items-center justify-center overflow-y-auto">
        <!-- Language Toggle -->
        <button onclick="Lang.toggle()" class="absolute top-6 right-6 bg-slate-800 text-slate-400 hover:text-white px-3 py-1 rounded-lg font-bold text-xs border border-slate-700 flex items-center gap-2">
            <i class="ph ph-globe"></i> <span id="lbl-lang">EN</span>
        </button>

        <div class="text-center max-w-md w-full p-6 my-auto">
            <h1 class="text-5xl font-black text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-600 mb-2">MAZEMAZING</h1>
            <p class="text-slate-500 mb-8 font-mono text-sm" data-i18n="subtitle">3D / 2D Engine • Pro</p>

            <div class="space-y-3" id="menu-list">
                <button data-nav="true" onclick="Game.start('easy')" class="w-full bg-emerald-600 hover:bg-emerald-500 text-white py-4 rounded-xl font-bold shadow-lg transition transform active:scale-95 border-2 border-transparent" data-i18n="easy">Easy (10x10)</button>
                <button data-nav="true" onclick="Game.start('medium')" class="w-full bg-amber-600 hover:bg-amber-500 text-white py-4 rounded-xl font-bold shadow-lg transition transform active:scale-95 border-2 border-transparent" data-i18n="medium">Medium (25x25)</button>
                <button data-nav="true" onclick="Game.start('hard')" class="w-full bg-rose-600 hover:bg-rose-500 text-white py-4 rounded-xl font-bold shadow-lg transition transform active:scale-95 border-2 border-transparent" data-i18n="hard">Hard (50x50)</button>
                <!-- EXTREME MODE BUTTON -->
                <button data-nav="true" onclick="Game.start('extreme')" class="w-full bg-purple-700 hover:bg-purple-600 text-white py-4 rounded-xl font-bold shadow-lg transition transform active:scale-95 border-2 border-transparent ring-1 ring-purple-400/50" data-i18n="extreme">Extreme (100x100)</button>
                
                <div class="relative py-4 flex items-center">
                    <div class="flex-grow border-t border-slate-800"></div>
                    <span class="flex-shrink-0 mx-4 text-slate-600 text-xs font-bold" data-i18n="code_label">OR USE A CODE</span>
                    <div class="flex-grow border-t border-slate-800"></div>
                </div>

                <div class="bg-slate-900/50 p-3 rounded-xl border border-slate-800 space-y-2">
                    <div class="flex gap-2">
                        <input id="inp-code" type="text" placeholder="CODE" class="input-glow flex-1 bg-slate-950 border border-slate-700 text-cyan-400 font-mono font-bold text-center rounded-lg px-2 h-10 focus:outline-none focus:border-cyan-500 transition placeholder-slate-600 uppercase">
                        <button onclick="Utils.randomCode('inp-code')" class="w-10 h-10 bg-slate-800 text-slate-300 hover:text-white rounded-lg flex items-center justify-center transition" title="Random Code">
                            <i class="ph ph-dice-five text-xl"></i>
                        </button>
                    </div>
                    
                    <div class="flex gap-2">
                         <select id="inp-size" class="h-10 bg-slate-950 text-slate-300 border border-slate-700 rounded-lg px-2 text-xs font-bold outline-none focus:border-cyan-500">
                             <option value="11">SMALL (10x10)</option>
                             <option value="25" selected>MEDIUM (25x25)</option>
                             <option value="51">LARGE (50x50)</option>
                             <option value="101">EXTREME (100x100)</option>
                         </select>
                         <button onclick="Game.start('code')" class="flex-1 h-10 bg-cyan-700 hover:bg-cyan-600 text-white rounded-lg font-bold shadow-lg transition transform active:scale-95 text-sm" data-i18n="load_map">
                             LOAD MAP
                         </button>
                    </div>
                </div>

                <div class="h-4"></div>
                <button data-nav="true" onclick="Editor.open()" class="w-full bg-slate-800 hover:bg-slate-700 text-slate-300 py-3 rounded-xl font-bold shadow-lg flex items-center justify-center gap-2 border-2 border-transparent transition">
                    <i class="ph ph-pencil-simple"></i> <span data-i18n="map_editor">Map Editor</span>
                </button>
                
                <div class="flex justify-center mt-4">
                    <button onclick="Sfx.toggle()" class="text-slate-500 hover:text-white transition flex items-center gap-2 text-sm font-bold">
                        <i id="icon-sound" class="ph ph-speaker-high text-lg"></i> <span id="txt-sound" data-i18n="sound_on">Sound On</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Game UI -->
    <div id="screen-game" class="ui-screen hidden justify-between p-4 z-40">
        <div class="flex justify-between w-full interactive items-start">
            <!-- Top Left: Exit & Code Info -->
            <div class="flex flex-col md:flex-row md:items-center gap-2 md:gap-4">
                <button onclick="Game.quit()" class="bg-red-950/80 backdrop-blur text-red-200 border border-red-900/50 px-3 py-2 rounded-lg font-bold shadow-lg text-sm transition active:scale-95 flex items-center gap-2 btn-game-ui w-fit">
                    <i class="ph ph-sign-out text-lg"></i><span data-i18n="exit">Exit</span>
                </button>
                 <div id="ui-code-display" class="hidden bg-slate-900/60 backdrop-blur text-slate-400 border border-slate-800 px-3 py-2 rounded-lg text-xs font-mono shadow-md whitespace-nowrap w-fit">
                    <span class="opacity-50 mr-1">MAP:</span> <span class="text-cyan-400 font-bold tracking-wider" id="ui-code-val">---</span>
                </div>
            </div>

            <!-- Top Right: View Controls & Minimap -->
            <div class="flex flex-col items-end gap-2">
                <!-- Toggle Row -->
                <div class="flex gap-2">
                    <!-- 2D/3D Toggle -->
                    <button onclick="Game.toggleDimension()" class="bg-slate-900/80 backdrop-blur text-cyan-400 border border-cyan-900/50 px-3 py-2 rounded-lg font-bold shadow-lg flex items-center gap-2 text-sm transition active:scale-95 btn-game-ui">
                        <i id="icon-dim" class="ph ph-cube text-lg"></i> <span id="lbl-dim" data-i18n="view_3d">3D View</span> <span class="key-badge hidden md:inline">M</span>
                    </button>
                    <!-- POV Toggle (1st/3rd) -->
                    <button id="btn-pov" onclick="Game.toggleCamera()" class="bg-slate-900/80 backdrop-blur text-emerald-400 border border-emerald-900/50 px-3 py-2 rounded-lg font-bold shadow-lg flex items-center gap-2 text-sm transition active:scale-95 btn-game-ui">
                        <i id="icon-pov" class="ph ph-person text-lg"></i> <span id="lbl-pov" data-i18n="view_3rd">3rd Person</span> <span class="key-badge hidden md:inline">V</span>
                    </button>
                </div>

                <div id="minimap-wrapper">
                    <canvas id="minimap"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- Editor UI - DESKTOP REDESIGN -->
    <div id="screen-editor" class="ui-screen hidden bg-slate-950 z-50 flex-col interactive font-sans">
        <!-- Header -->
        <div class="h-16 bg-slate-900 border-b border-slate-800 flex items-center justify-between px-4 md:px-6 shrink-0 shadow-lg z-20">
            <div class="flex items-center gap-3">
                <div class="w-8 h-8 bg-cyan-600 rounded-lg flex items-center justify-center text-white shadow-cyan-500/20 shadow-lg hidden md:flex">
                    <i class="ph ph-pencil-simple-line text-xl"></i>
                </div>
                <div>
                    <h2 class="font-bold text-slate-100 text-lg leading-tight flex items-center gap-2"><i class="ph ph-pencil-simple-line md:hidden text-cyan-400"></i> <span data-i18n="map_editor">Map Editor</span></h2>
                    <p class="text-xs text-slate-500 font-mono hidden md:block">DESIGN MODE</p>
                </div>
            </div>
            <div class="flex gap-3">
                <button onclick="Editor.close()" class="bg-slate-800 hover:bg-slate-700 text-slate-300 hover:text-white px-4 py-2 rounded-lg font-bold text-sm transition border border-slate-700">
                    <span data-i18n="back">Back</span>
                </button>
                <button onclick="Game.start('custom')" class="bg-green-600 hover:bg-green-500 text-white px-5 py-2 rounded-lg font-bold shadow-lg flex items-center gap-2 text-sm transition transform active:scale-95">
                    <i class="ph ph-play-circle text-lg"></i> <span data-i18n="play">Play</span>
                </button>
            </div>
        </div>

        <div class="flex flex-1 overflow-hidden flex-col-reverse md:flex-row relative">
            
            <!-- Sidebar (Desktop: Left, Mobile: Bottom - Responsive Grid) -->
            <div class="w-full md:w-72 bg-slate-900 border-t md:border-t-0 md:border-r border-slate-800 flex flex-col z-10 shadow-xl overflow-y-auto custom-scroll shrink-0 max-h-[40vh] md:max-h-full">
                <div class="p-2 md:p-4 grid grid-cols-2 md:flex md:flex-col gap-2 md:space-y-6">
                    
                    <!-- Group 1: Tools & Brushes (Left Column on Mobile) -->
                    <div class="space-y-2 md:space-y-6 flex flex-col">
                        <!-- Tools Section -->
                        <div class="space-y-1 md:space-y-2">
                            <h3 class="text-[10px] md:text-xs font-bold text-slate-500 uppercase tracking-wider hidden md:block">Mode</h3>
                            <div class="flex bg-slate-950 p-1 rounded-lg border border-slate-800">
                                <button onclick="Editor.setMode('draw')" id="btn-mode-draw" class="flex-1 py-1 md:py-2 rounded-md transition flex justify-center items-center text-[10px] md:text-xs font-bold gap-2">
                                    <i class="ph ph-pencil-simple text-sm md:text-lg"></i> <span class="hidden sm:inline" data-i18n="draw">DRAW</span>
                                </button>
                                <button onclick="Editor.setMode('pan')" id="btn-mode-pan" class="flex-1 py-1 md:py-2 rounded-md transition flex justify-center items-center text-[10px] md:text-xs font-bold gap-2">
                                    <i class="ph ph-hand-grabbing text-sm md:text-lg"></i> <span class="hidden sm:inline" data-i18n="pan">PAN</span>
                                </button>
                            </div>
                        </div>

                        <!-- Brushes Section -->
                        <div class="space-y-1 md:space-y-2 flex-1">
                             <h3 class="text-[10px] md:text-xs font-bold text-slate-500 uppercase tracking-wider hidden md:block">Brushes</h3>
                             <div class="grid grid-cols-4 md:grid-cols-2 gap-1 md:gap-2 h-full">
                                 <button onclick="Editor.setTool(1)" id="t-1" class="tool-btn h-12 md:h-20 bg-slate-800 hover:bg-slate-700 rounded-lg border-2 border-transparent transition flex flex-col items-center justify-center gap-1 md:gap-2 group">
                                    <div class="w-4 h-4 md:w-8 md:h-8 bg-slate-500 border border-slate-400 rounded group-hover:scale-110 transition"></div>
                                    <span class="text-[9px] md:text-xs font-bold text-slate-400 group-hover:text-white hidden md:block" data-i18n="wall">Wall</span>
                                 </button>
                                 <button onclick="Editor.setTool(0)" id="t-0" class="tool-btn h-12 md:h-20 bg-slate-800 hover:bg-slate-700 rounded-lg border-2 border-transparent transition flex flex-col items-center justify-center gap-1 md:gap-2 group">
                                    <div class="w-4 h-4 md:w-8 md:h-8 bg-slate-950 border border-slate-600 rounded group-hover:scale-110 transition"></div>
                                    <span class="text-[9px] md:text-xs font-bold text-slate-400 group-hover:text-white hidden md:block" data-i18n="path">Path</span>
                                 </button>
                                 <button onclick="Editor.setTool(2)" id="t-2" class="tool-btn h-12 md:h-20 bg-slate-800 hover:bg-slate-700 rounded-lg border-2 border-transparent transition flex flex-col items-center justify-center gap-1 md:gap-2 group">
                                    <div class="w-4 h-4 md:w-8 md:h-8 bg-emerald-500 rounded-full group-hover:scale-110 transition"></div>
                                    <span class="text-[9px] md:text-xs font-bold text-slate-400 group-hover:text-white hidden md:block" data-i18n="start">Start</span>
                                 </button>
                                 <button onclick="Editor.setTool(3)" id="t-3" class="tool-btn h-12 md:h-20 bg-slate-800 hover:bg-slate-700 rounded-lg border-2 border-transparent transition flex flex-col items-center justify-center gap-1 md:gap-2 group">
                                    <div class="w-4 h-4 md:w-8 md:h-8 bg-red-500 rounded-full shadow-[0_0_8px_red] group-hover:scale-110 transition"></div>
                                    <span class="text-[9px] md:text-xs font-bold text-slate-400 group-hover:text-white hidden md:block" data-i18n="end">End</span>
                                 </button>
                             </div>
                        </div>
                    </div>

                    <!-- Divider (Hidden on Mobile) -->
                    <div class="h-px bg-slate-800 hidden md:block"></div>

                    <!-- Group 2: Settings & Gen (Right Column on Mobile) -->
                    <div class="space-y-2 md:space-y-6 flex flex-col justify-between">
                        <!-- Settings Section -->
                        <div class="space-y-2 md:space-y-4">
                            <h3 class="text-[10px] md:text-xs font-bold text-slate-500 uppercase tracking-wider hidden md:block">Properties</h3>
                            
                            <div class="space-y-1">
                                <div class="flex justify-between text-[10px] md:text-xs text-slate-400">
                                    <span data-i18n="prop_grid">Grid Size</span> <span id="lbl-size" class="font-mono text-cyan-400">10x</span>
                                </div>
                                <input type="range" min="10" max="100" step="5" value="10" onchange="Editor.resize(this.value)" class="w-full accent-cyan-500 h-1 bg-slate-800 rounded-lg appearance-none cursor-pointer">
                            </div>

                            <div class="space-y-1">
                                <div class="flex justify-between text-[10px] md:text-xs text-slate-400">
                                    <span data-i18n="prop_zoom">Zoom Level</span>
                                </div>
                                <input type="range" min="0.5" max="3" step="0.1" value="1" oninput="Editor.setZoom(this.value)" class="w-full accent-cyan-500 h-1 bg-slate-800 rounded-lg appearance-none cursor-pointer">
                            </div>
                        </div>

                        <!-- Generator Section -->
                        <div class="bg-slate-950 p-2 md:p-3 rounded-xl border border-slate-800 space-y-2 md:space-y-3">
                            <h3 class="text-[10px] md:text-xs font-bold text-slate-500 uppercase tracking-wider flex items-center gap-2"><i class="ph ph-magic-wand"></i> <span class="hidden sm:inline" data-i18n="gen_title">Generator</span></h3>
                            
                            <div class="flex gap-2">
                                <div class="relative flex-1">
                                    <input id="ed-code" type="text" placeholder="SEED" class="w-full bg-slate-900 border border-slate-700 text-white text-[10px] md:text-xs px-2 h-6 md:h-8 rounded uppercase font-mono focus:border-cyan-500 outline-none">
                                    <button onclick="Utils.randomCode('ed-code')" class="absolute right-1 top-0.5 text-slate-500 hover:text-white p-1"><i class="ph ph-dice-five"></i></button>
                                </div>
                                <select id="ed-size" class="bg-slate-900 text-slate-300 border border-slate-700 rounded text-[10px] md:text-xs h-6 md:h-8 px-1 w-12 md:w-14">
                                    <option value="11">10x</option>
                                    <option value="25" selected>25x</option>
                                    <option value="51">50x</option>
                                    <option value="101">100x</option>
                                </select>
                            </div>
                            <button onclick="Editor.generateFromCode()" class="w-full bg-cyan-700 hover:bg-cyan-600 text-white text-[10px] md:text-xs h-6 md:h-8 rounded font-bold transition" data-i18n="gen">GEN</button>
                        </div>

                        <button onclick="Editor.clear()" class="w-full border border-red-900/50 text-red-400 hover:bg-red-900/20 py-2 md:py-3 rounded-lg text-[10px] md:text-xs font-bold flex items-center justify-center gap-2 transition">
                            <i class="ph ph-trash text-sm md:text-lg"></i> <span class="hidden sm:inline" data-i18n="clear">CLEAR MAP</span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Viewport -->
            <div id="editor-viewport" class="flex-1 bg-grid-pattern relative p-4 md:p-8 mode-draw overflow-hidden flex items-center justify-center">
                <div id="editor-grid"></div>
            </div>
        </div>
    </div>

    <!-- Victory -->
    <div id="screen-victory" class="ui-screen hidden bg-black/95 interactive items-center justify-center z-[100] text-center p-6">
        <div class="max-w-sm w-full bg-slate-900 p-8 rounded-3xl border border-yellow-500/20 shadow-2xl">
            <i class="ph ph-crown text-6xl text-yellow-400 mb-4 inline-block animate-bounce"></i>
            <h2 class="text-4xl font-black text-white mb-2" data-i18n="complete">COMPLETE!</h2>
            <div class="text-2xl font-mono text-cyan-400 font-bold mb-6 bg-slate-950 p-2 rounded-lg border border-slate-800" id="victory-time">00:00</div>
            <button onclick="Game.quit()" class="w-full bg-cyan-600 hover:bg-cyan-500 text-white py-4 rounded-xl font-bold shadow-lg transition" data-i18n="main_menu">Main Menu</button>
        </div>
    </div>

    <script>
        // PWA Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js').catch(()=>{});
            });
        }

        const CONST = {
            WALL: 1, PATH: 0, START: 2, END: 3,
            CELL_SIZE: 4, 
            // OLD: SPEED_3D: 0.05, SPEED_2D: 0.15, ROT_SPEED: 0.04
            // NEW (Per Second):
            SPEED_3D: 3.5, 
            SPEED_2D: 10.0,
            ROT_SPEED: 2.5, 
            COLLISION_RADIUS: 0.2
        };

        // --- LANGUAGE SYSTEM (EN/TR) ---
        const Lang = {
            current: 'en',
            data: {
                en: {
                    title: "MAZEMAZING", subtitle: "3D / 2D Engine • Pro",
                    easy: "Easy (10x10)", medium: "Medium (25x25)", hard: "Hard (50x50)", extreme: "Extreme (100x100)",
                    code_label: "OR USE A CODE", load_map: "LOAD MAP", map_editor: "Map Editor",
                    sound_on: "Sound On", sound_off: "Sound Off",
                    exit: "Exit", view_3d: "3D View", view_2d: "2D Map", view_3rd: "3rd Person",
                    back: "Back", play: "Play", draw: "DRAW", pan: "PAN",
                    wall: "Wall", path: "Path", start: "Start", end: "End",
                    prop_grid: "Grid Size", prop_zoom: "Zoom Level", gen_title: "Generator", gen: "GEN", clear: "CLEAR MAP",
                    complete: "COMPLETE!", main_menu: "Main Menu", hint_move: "Move", hint_map: "Map", hint_view: "View"
                },
                tr: {
                    title: "MAZEMAZING", subtitle: "3D / 2D Motoru • Pro",
                    easy: "Kolay (10x10)", medium: "Orta (25x25)", hard: "Zor (50x50)", extreme: "Ekstrem (100x100)",
                    code_label: "VEYA KOD KULLAN", load_map: "HARİTA YÜKLE", map_editor: "Harita Editörü",
                    sound_on: "Ses Açık", sound_off: "Ses Kapalı",
                    exit: "Çıkış", view_3d: "3D Görünüm", view_2d: "2D Harita", view_3rd: "3. Şahıs",
                    back: "Geri", play: "Oyna", draw: "ÇİZ", pan: "KAYDIR",
                    wall: "Duvar", path: "Yol", start: "Başla", end: "Bitiş",
                    prop_grid: "Izgara Boyutu", prop_zoom: "Yakınlaştırma", gen_title: "Oluşturucu", gen: "ÜRET", clear: "TEMİZLE",
                    complete: "TAMAMLANDI!", main_menu: "Ana Menü", hint_move: "Hareket", hint_map: "Harita", hint_view: "Görünüm"
                }
            },
            toggle() {
                this.current = this.current === 'en' ? 'tr' : 'en';
                this.apply();
            },
            apply() {
                const dict = this.data[this.current];
                document.getElementById('lbl-lang').innerText = this.current.toUpperCase();
                document.querySelectorAll('[data-i18n]').forEach(el => {
                    const key = el.getAttribute('data-i18n');
                    if(dict[key]) el.innerText = dict[key];
                });
                // Update sound text manually if needed
                const sfxText = Sfx.enabled ? dict.sound_on : dict.sound_off;
                document.getElementById('txt-sound').innerText = sfxText;
            },
            get(key) { return this.data[this.current][key] || key; }
        };

        const Utils = {
            randomCode(inputId) {
                const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789"; 
                let result = "";
                for(let i=0; i<5; i++) result += chars.charAt(Math.floor(Math.random() * chars.length));
                document.getElementById(inputId).value = result;
            }
        };

        // --- MENU KEYBOARD NAVIGATION ---
        const MenuNav = {
            index: -1,
            buttons: [],
            init() {
                this.buttons = Array.from(document.querySelectorAll('#menu-list button[data-nav="true"]'));
                this.index = -1;
                this.updateFocus();
            },
            move(dir) {
                if(this.buttons.length === 0) this.init();
                this.index += dir;
                if(this.index < 0) this.index = this.buttons.length - 1;
                if(this.index >= this.buttons.length) this.index = 0;
                this.updateFocus();
            },
            updateFocus() {
                this.buttons.forEach((b, i) => {
                    if(i === this.index) b.classList.add('menu-focus');
                    else b.classList.remove('menu-focus');
                });
            },
            select() {
                if(this.index > -1 && this.buttons[this.index]) {
                    this.buttons[this.index].click();
                }
            }
        };

        // --- PROCEDURAL SOUND SYSTEM ---
        const Sfx = {
            ctx: null, enabled: true,
            init() {
                if(!this.ctx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if(AudioContext) this.ctx = new AudioContext();
                }
                if(this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
            },
            toggle() {
                this.enabled = !this.enabled;
                const i = document.getElementById('icon-sound');
                const t = document.getElementById('txt-sound');
                const dict = Lang.data[Lang.current];
                if(this.enabled) { 
                    i.className="ph ph-speaker-high"; 
                    t.innerText=dict.sound_on; 
                } else { 
                    i.className="ph ph-speaker-slash"; 
                    t.innerText=dict.sound_off; 
                }
                this.click();
            },
            playTone(freq, type, dur, vol=0.1, slide=0) {
                if(!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                if(slide !== 0) osc.frequency.linearRampToValueAtTime(freq + slide, this.ctx.currentTime + dur);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + dur);
            },
            playNoise(dur, vol=0.1) {
                if(!this.enabled || !this.ctx) return;
                const bufSize = this.ctx.sampleRate * dur;
                const buffer = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 800;
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start();
            },
            click() { this.playTone(800, 'triangle', 0.05, 0.05); },
            step() { this.playNoise(0.05, 0.03); },
            win() {
                if(!this.enabled) return;
                [0, 150, 300, 450].forEach((d, i) => {
                    setTimeout(() => this.playTone(440 + (i*110), 'triangle', 0.3, 0.1), d);
                });
            }
        };

        // --- PROCEDURAL TEXTURES ---
        const TexGen = {
            createWall() {
                const s = 512;
                const c = document.createElement('canvas'); c.width=s; c.height=s;
                const ctx = c.getContext('2d');
                ctx.fillStyle = '#1e293b'; ctx.fillRect(0,0,s,s);
                ctx.fillStyle = '#334155'; const padding = 20; ctx.fillRect(padding, padding, s-padding*2, s-padding*2);
                ctx.fillStyle = '#64748b'; const r = 4; const locs = [40, s-40];
                locs.forEach(x => locs.forEach(y => { ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); }));
                ctx.strokeStyle = '#0ea5e9'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(40, s/2); ctx.lineTo(s-40, s/2); ctx.stroke();
                const tex = new THREE.CanvasTexture(c); tex.magFilter = THREE.NearestFilter; return tex;
            },
            createFloor() {
                const s = 512;
                const c = document.createElement('canvas'); c.width=s; c.height=s;
                const ctx = c.getContext('2d');
                ctx.fillStyle = '#020617'; ctx.fillRect(0,0,s,s);
                ctx.strokeStyle = 'rgba(34, 211, 238, 0.2)'; ctx.lineWidth = 4;
                ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(s,0); ctx.lineTo(s,s); ctx.stroke();
                const tex = new THREE.CanvasTexture(c); tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping; return tex;
            }
        };

        const Timer = {
            el: null, elapsed: 0, lastTick: 0, interval: null, running: false,
            init() { this.el = document.getElementById('game-timer'); },
            start() {
                this.running = true; this.elapsed = 0; this.lastTick = Date.now();
                this.el.style.display = 'block'; this.update();
                this.interval = setInterval(() => this.update(), 100);
            },
            stop() { this.running = false; clearInterval(this.interval); return this.format(this.elapsed); },
            reset() { this.running = false; clearInterval(this.interval); this.elapsed = 0; this.el.style.display = 'none'; this.el.innerText = '00:00'; },
            update() {
                if(!this.running) return;
                const now = Date.now(); const delta = now - this.lastTick; this.lastTick = now;
                const multiplier = (!Game.is2D) ? 1 : (CONST.SPEED_2D / CONST.SPEED_3D);
                this.elapsed += delta * multiplier;
                this.el.innerText = this.format(this.elapsed);
            },
            format(ms) {
                const totalSecs = Math.floor(ms / 1000);
                const m = Math.floor(totalSecs / 60).toString().padStart(2, '0');
                const s = (totalSecs % 60).toString().padStart(2, '0');
                return `${m}:${s}`;
            }
        };

        const Seed = {
            rng: Math.random, current: null,
            hash(str) { let h = 0x811c9dc5; for (let i = 0; i < str.length; i++) { h ^= str.charCodeAt(i); h = Math.imul(h, 0x01000193); } return h >>> 0; },
            mulberry32(a) { return function() { var t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; } },
            set(code) { if(!code) { this.reset(); return; } const seedInt = this.hash(code); this.rng = this.mulberry32(seedInt); this.current = code; },
            reset() { this.rng = Math.random; this.current = null; }
        };

        class Joystick {
            constructor(zoneId, thumbId, maxDist = 40) {
                this.zone = document.getElementById(zoneId); this.thumb = document.getElementById(thumbId);
                this.maxDist = maxDist; this.active = false; this.data = { x: 0, y: 0 }; this.origin = { x: 0, y: 0 };
                this.bindEvents();
            }
            bindEvents() {
                const handleStart = (e) => {
                    e.preventDefault(); this.active = true;
                    const rect = this.zone.getBoundingClientRect();
                    this.origin = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
                    this.update(e); this.zone.querySelector('.stick-base').style.borderColor = "rgba(34, 211, 238, 0.5)";
                };
                const handleMove = (e) => { if(!this.active) return; e.preventDefault(); this.update(e); };
                const handleEnd = (e) => {
                    e.preventDefault(); this.active = false; this.data = {x:0, y:0};
                    this.thumb.style.transform = `translate(-50%, -50%)`;
                    this.zone.querySelector('.stick-base').style.borderColor = "";
                };
                this.zone.addEventListener('touchstart', handleStart, {passive: false});
                this.zone.addEventListener('touchmove', handleMove, {passive: false});
                this.zone.addEventListener('touchend', handleEnd); this.zone.addEventListener('touchcancel', handleEnd);
            }
            update(e) {
                const touch = e.targetTouches ? e.targetTouches[0] : e;
                const dx = touch.clientX - this.origin.x; const dy = touch.clientY - this.origin.y;
                const dist = Math.sqrt(dx*dx + dy*dy); const angle = Math.atan2(dy, dx);
                const clamped = Math.min(dist, this.maxDist);
                const tx = Math.cos(angle) * clamped; const ty = Math.sin(angle) * clamped;
                this.thumb.style.transform = `translate(calc(-50% + ${tx}px), calc(-50% + ${ty}px))`;
                this.data.x = tx / this.maxDist; this.data.y = ty / this.maxDist;
            }
        }

        const Input = {
            keys: { w:false, s:false, l:false, r:false }, stick: null, initialized: false,
            init() {
                if(this.initialized) return; this.initialized = true;
                const k = (e,v) => {
                    const key = e.key.toLowerCase();
                    // Movement
                    if(key==='w'||key==='arrowup') this.keys.w=v; if(key==='s'||key==='arrowdown') this.keys.s=v;
                    if(key==='a'||key==='arrowleft') this.keys.l=v; if(key==='d'||key==='arrowright') this.keys.r=v;
                    
                    if (v) {
                        // Global Esc
                        if(key === 'escape') {
                            if(Game.running) Game.quit();
                            if(!document.getElementById('screen-editor').classList.contains('hidden')) Editor.close();
                        }

                        // Game Shortcuts
                        if (Game.running) {
                            if (key === 'm') Game.toggleDimension();
                            if (key === 'v') Game.toggleCamera();
                        }

                        // Menu Navigation (Only if menu is visible)
                        const menu = document.getElementById('screen-menu');
                        if (!menu.classList.contains('hidden')) {
                            if(key === 'arrowup') { MenuNav.move(-1); Sfx.click(); }
                            if(key === 'arrowdown') { MenuNav.move(1); Sfx.click(); }
                            if(key === 'enter') { MenuNav.select(); Sfx.click(); }
                        }
                    }
                };
                window.addEventListener('keydown', e=>k(e,true)); window.addEventListener('keyup', e=>k(e,false));
                if('ontouchstart' in window || navigator.maxTouchPoints > 0) { this.stick = new Joystick('stick-zone', 'stick-thumb'); } 
                else { document.getElementById('controls-hint').classList.remove('hidden'); }
            },
            get(is3D) {
                let dx = 0, dz = 0, rot = 0;
                if (is3D) {
                    if(this.keys.w) dz = 1; if(this.keys.s) dz = -1;
                    if(this.keys.l) rot = 1; if(this.keys.r) rot = -1;
                } else {
                    if(this.keys.w) dz = -1; if(this.keys.s) dz = 1;
                    if(this.keys.l) dx = -1; if(this.keys.r) dx = 1;
                }
                if(this.stick && this.stick.active) {
                    const sx = this.stick.data.x; const sy = this.stick.data.y;
                    if(is3D) { dz = -sy; rot = -sx; } else { dx = sx; dz = sy; }
                }
                return { dx, dz, rot };
            }
        };

        const MazeGen = {
            generate(w, h, rng = Math.random) {
                let map = Array(h).fill().map(() => Array(w).fill(CONST.WALL));
                const stack = [];
                const randOdd = (limit) => Math.floor(rng() * Math.floor((limit - 1) / 2)) * 2 + 1;
                let genX = randOdd(w); let genY = randOdd(h);
                map[genY][genX] = CONST.PATH; stack.push({x: genX, y: genY});
                const dirs = [{x:0, y:-2}, {x:0, y:2}, {x:-2, y:0}, {x:2, y:0}];
                while(stack.length > 0) {
                    const current = stack[stack.length - 1];
                    const neighbors = [];
                    for(let d of dirs) {
                        const nx = current.x + d.x; const ny = current.y + d.y;
                        if(nx > 0 && nx < w-1 && ny > 0 && ny < h-1 && map[ny][nx] === CONST.WALL) {
                            neighbors.push({x: nx, y: ny, dx: d.x/2, dy: d.y/2});
                        }
                    }
                    if(neighbors.length > 0) {
                        const next = neighbors[Math.floor(rng() * neighbors.length)];
                        map[next.y][next.x] = CONST.PATH; map[current.y + next.dy][current.x + next.dx] = CONST.PATH;
                        stack.push({x: next.x, y: next.y});
                    } else { stack.pop(); }
                }
                const deadEnds = [];
                for(let y = 1; y < h - 1; y++) {
                    for(let x = 1; x < w - 1; x++) {
                        if(map[y][x] === CONST.PATH) {
                            let neighbors = 0;
                            if(map[y-1][x] !== CONST.WALL) neighbors++; if(map[y+1][x] !== CONST.WALL) neighbors++;
                            if(map[y][x-1] !== CONST.WALL) neighbors++; if(map[y][x+1] !== CONST.WALL) neighbors++;
                            if(neighbors === 1) deadEnds.push({x, y});
                        }
                    }
                }
                if(deadEnds.length < 2) deadEnds.push({x: genX, y: genY});
                const startIndex = Math.floor(rng() * deadEnds.length);
                const startNode = deadEnds[startIndex];
                map[startNode.y][startNode.x] = CONST.START;
                const candidates = deadEnds.filter((_, i) => i !== startIndex).map(d => {
                    return { node: d, dist: Math.abs(d.x - startNode.x) + Math.abs(d.y - startNode.y) };
                });
                candidates.sort((a, b) => b.dist - a.dist);
                const topCount = Math.max(1, Math.min(5, Math.floor(candidates.length * 0.2)));
                const chosenCandidate = candidates[Math.floor(rng() * topCount)] || candidates[0];
                const bestEnd = chosenCandidate ? chosenCandidate.node : deadEnds[(startIndex + 1) % deadEnds.length];
                map[bestEnd.y][bestEnd.x] = CONST.END;
                return map;
            }
        };

        const GFX = {
            scene: null, camera: null, renderer: null, wallsMesh: null,
            wallTex: null, floorTex: null, playerMesh: null,
            init() {
                if(this.renderer) return;
                const cvs = document.getElementById('c3d');
                this.renderer = new THREE.WebGLRenderer({ canvas: cvs, antialias: false });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x020617);
                this.scene.fog = new THREE.Fog(0x020617, 2, 20);
                this.camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 100);
                
                // Add Lights & Mark as Persistent
                const ambient = new THREE.AmbientLight(0xffffff, 0.4);
                ambient.userData.keep = true;
                this.scene.add(ambient);

                this.pl = new THREE.PointLight(0x38bdf8, 1.5, 12);
                this.pl.userData.keep = true;
                this.scene.add(this.pl);
                
                // Camera is naturally persistent
                this.camera.userData.keep = true;

                // Textures
                this.wallTex = TexGen.createWall();
                this.floorTex = TexGen.createFloor();

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            },
            createPlayer() {
                const group = new THREE.Group();
                // Body
                const bodyGeo = new THREE.BoxGeometry(1, 1.8, 1);
                const bodyMat = new THREE.MeshLambertMaterial({ color: 0x22d3ee });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 0.9;
                group.add(body);
                // Visor
                const visorGeo = new THREE.BoxGeometry(0.8, 0.4, 0.2);
                const visorMat = new THREE.MeshLambertMaterial({ color: 0x000000 });
                const visor = new THREE.Mesh(visorGeo, visorMat);
                visor.position.set(0, 1.4, -0.5); // Facing Negative Z
                group.add(visor);
                
                return group;
            },
            build(map, w, h) {
                if (!this.scene) this.init();
                
                // Cleanup: Remove objects that are NOT marked as 'keep'
                for(let i = this.scene.children.length - 1; i >= 0; i--) {
                     const c = this.scene.children[i];
                     if(!c.userData.keep) { 
                         this.scene.remove(c); 
                         if(c.geometry) c.geometry.dispose(); 
                         if(c.material) c.material.dispose();
                     }
                }
                
                // Player Mesh
                this.playerMesh = this.createPlayer();
                this.scene.add(this.playerMesh);

                // Floor (moved from y=-2 to y=0)
                const floorGeo = new THREE.PlaneGeometry(w*4, h*4);
                this.floorTex.repeat.set(w/2, h/2);
                const floorMat = new THREE.MeshLambertMaterial({ map: this.floorTex });
                const floor = new THREE.Mesh(floorGeo, floorMat);
                floor.rotation.x = -Math.PI/2;
                floor.position.set(w*2, 0, h*2); 
                this.scene.add(floor);

                // Walls
                const wallCount = map.flat().filter(c => c === CONST.WALL).length;
                const geo = new THREE.BoxGeometry(4, 4, 4);
                const mat = new THREE.MeshLambertMaterial({ map: this.wallTex });
                this.wallsMesh = new THREE.InstancedMesh(geo, mat, wallCount);
                
                const dummy = new THREE.Object3D();
                let idx = 0;
                for(let z=0; z<h; z++) {
                    for(let x=0; x<w; x++) {
                        const t = map[z][x];
                        const worldX = x * 4 + 2; const worldZ = z * 4 + 2;
                        if(t === CONST.WALL) {
                            dummy.position.set(worldX, 2, worldZ);
                            dummy.updateMatrix();
                            this.wallsMesh.setMatrixAt(idx++, dummy.matrix);
                        } else if(t === CONST.END) {
                            const orb = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), new THREE.MeshBasicMaterial({ color: 0xef4444 }));
                            orb.position.set(worldX, 2, worldZ);
                            this.scene.add(orb);
                            const pl = new THREE.PointLight(0xff0000, 2, 8);
                            pl.position.set(worldX, 2, worldZ); 
                            this.scene.add(pl);
                        }
                    }
                }
                this.scene.add(this.wallsMesh);
            },
            
            // --- PHYSICS CAMERA CLIP ---
            getSafeCameraPos(px, pz, tx, tz, map, w, h) {
                // Raycast-lite: Check points along the line from Player to Target
                const dx = tx - px;
                const dz = tz - pz;
                const dist = Math.sqrt(dx*dx + dz*dz);
                const steps = Math.ceil(dist * 2); // Check every 0.5 units
                
                // Buffer to keep camera slightly away from wall
                const buffer = 0.5;

                for(let i = 1; i <= steps; i++) {
                    const t = i / steps;
                    const cx = px + dx * t;
                    const cz = pz + dz * t;
                    
                    // Convert World Coords (units) to Grid Coords
                    // Map scale is 4 units per cell.
                    const gx = Math.floor(cx / 4);
                    const gz = Math.floor(cz / 4);
                    
                    if (gx >= 0 && gx < w && gz >= 0 && gz < h) {
                        if (map[gz][gx] === CONST.WALL) {
                            // Hit a wall! Return position just before this step
                            const safeT = Math.max(0, (i - 1.5) / steps);
                            return { 
                                x: px + dx * safeT, 
                                z: pz + dz * safeT 
                            };
                        }
                    }
                }
                return { x: tx, z: tz };
            },

            snapCamera: true, // Flag to reset lerp
            render(player, is2D, isThirdPerson) {
                // Update Player Mesh Position
                const px = player.x * 4;
                const pz = player.z * 4;
                
                if (this.playerMesh) {
                    this.playerMesh.position.set(px, 0, pz);
                    this.playerMesh.rotation.y = player.dir + Math.PI; 
                    this.playerMesh.visible = isThirdPerson;
                }

                // Camera Logic
                if (!is2D) {
                    if (isThirdPerson) {
                        // Smooth Third Person Camera with Wall Clipping Fix
                        const dist = 10;
                        const height = 10;
                        
                        // Ideal Position (Behind Player)
                        let targetX = px + Math.sin(player.dir) * dist;
                        let targetZ = pz + Math.cos(player.dir) * dist;
                        
                        // Check for walls between Player and Ideal Camera Position
                        const safePos = this.getSafeCameraPos(px, pz, targetX, targetZ, Game.map, Game.w, Game.h);
                        targetX = safePos.x;
                        targetZ = safePos.z;

                        if (this.snapCamera) {
                            this.camera.position.set(targetX, height, targetZ);
                            this.snapCamera = false;
                        } else {
                            // Lerp for smoothness
                            const idealPos = new THREE.Vector3(targetX, height, targetZ);
                            this.camera.position.lerp(idealPos, 0.1);
                        }
                        this.camera.lookAt(px, 1, pz); 
                    } else {
                        // First Person (Snappy)
                        this.camera.position.set(px, 1.6, pz);
                        const tx = px - Math.sin(player.dir);
                        const tz = pz - Math.cos(player.dir);
                        this.camera.lookAt(tx, 1.6, tz);
                        this.snapCamera = true; 
                    }
                    
                    this.pl.position.set(px, 5, pz);
                    this.renderer.render(this.scene, this.camera);
                }
            },
            render2D(map, w, h, p, cvsId) {
                const cvs = document.getElementById(cvsId);
                const ctx = cvs.getContext('2d');
                const isMini = cvsId === 'minimap';
                if(!isMini) {
                    if(cvs.width !== window.innerWidth) { cvs.width=window.innerWidth; cvs.height=window.innerHeight; }
                    ctx.fillStyle = '#020617'; ctx.fillRect(0,0,cvs.width,cvs.height);
                } else {
                    const wrapper = document.getElementById('minimap-wrapper');
                    if(cvs.width !== wrapper.clientWidth || cvs.height !== wrapper.clientHeight) {
                        cvs.width = wrapper.clientWidth;
                        cvs.height = wrapper.clientHeight;
                    }
                    ctx.fillStyle = "rgba(15, 23, 42, 0.95)"; ctx.fillRect(0,0,cvs.width,cvs.height);
                }
                const pad = isMini ? 0 : 40;
                const sw = cvs.width-pad; const sh = cvs.height-pad;
                const scale = Math.min(sw/w, sh/h);
                const ox = (cvs.width - w*scale)/2;
                const oy = (cvs.height - h*scale)/2;
                for(let z=0; z<h; z++) for(let x=0; x<w; x++) {
                    const t = map[z][x];
                    if(isMini && t!==CONST.WALL && t!==CONST.END && t!==CONST.START) continue;
                    this.drawCell(ctx, t, ox+x*scale, oy+z*scale, scale);
                }
                const px = ox + p.x*scale; const py = oy + p.z*scale;
                ctx.save();
                ctx.translate(px, py);
                if(isMini) ctx.rotate(-p.dir); else ctx.rotate(p.dir); 
                ctx.fillStyle = '#fbbf24';
                ctx.beginPath(); ctx.moveTo(0, -scale*0.7); ctx.lineTo(scale*0.4, scale*0.5); ctx.lineTo(0, scale*0.3); ctx.lineTo(-scale*0.4, scale*0.5); ctx.fill();
                ctx.restore();
            },
            drawCell(ctx, t, x, y, s) {
                if(t===CONST.WALL) ctx.fillStyle = '#475569';
                else if(t===CONST.END) ctx.fillStyle = '#ef4444';
                else if(t===CONST.START) ctx.fillStyle = '#10b981';
                else if(t===CONST.PATH && ctx.canvas.id !== 'minimap') ctx.fillStyle = '#0f172a';
                else return;
                ctx.fillRect(x,y,s+0.5,s+0.5);
            }
        };

        const Game = {
            running: false, is2D: false, isThirdPerson: false, 
            map: [], w: 0, h: 0,
            player: { x:1, z:1, dir: Math.PI },
            stepTimer: 0,

            init() {
                Input.init(); GFX.init(); Timer.init(); this.loop();
                MenuNav.init(); // Init keyboard menu
                document.querySelectorAll('button').forEach(b => b.addEventListener('click', () => Sfx.click()));
                document.getElementById('inp-code').addEventListener('keyup', (e)=>{ if(e.key === 'Enter') this.start('code'); });
            },
            start(mode) {
                Sfx.init(); 
                if (!GFX.scene) this.init(); 
                let w=15, h=15; let rng = Math.random;
                Timer.reset();
                if (mode === 'code') {
                    const rawCode = document.getElementById('inp-code').value.trim();
                    const sizeVal = parseInt(document.getElementById('inp-size').value);
                    if(!rawCode) return alert("Please enter a code!");
                    const code = rawCode.toUpperCase();
                    Seed.set(code); rng = Seed.rng; w = sizeVal; h = sizeVal;
                    document.getElementById('ui-code-display').classList.remove('hidden');
                    document.getElementById('ui-code-val').innerText = `${code} (${w}x${h})`;
                } else {
                    Seed.reset();
                    document.getElementById('ui-code-display').classList.add('hidden');
                    if(mode==='easy'){w=11;h=11;} 
                    if(mode==='medium'){w=25;h=25;} 
                    if(mode==='hard'){w=51;h=51;}
                    if(mode==='extreme'){w=101;h=101;} // 100x100 (Odd numbers for generator)
                }
                if(mode==='custom') { this.map=JSON.parse(JSON.stringify(Editor.grid)); this.w=this.map[0].length; this.h=this.map.length; } 
                else { this.map = MazeGen.generate(w, h, rng); this.w=w; this.h=h; }
                let found=false;
                for(let z=0;z<this.h;z++) for(let x=0;x<this.w;x++) if(this.map[z][x]===CONST.START) { this.player.x=x+0.5; this.player.z=z+0.5; found=true; }
                if(!found){this.player.x=1.5;this.player.z=1.5;}
                
                const startX = Math.floor(this.player.x);
                const startZ = Math.floor(this.player.z);
                
                const isPath = (x, z) => {
                    if (x < 0 || x >= this.w || z < 0 || z >= this.h) return false;
                    return this.map[z][x] !== CONST.WALL;
                };

                let startDir = Math.PI;

                if (isPath(startX, startZ - 1)) startDir = 0;           
                else if (isPath(startX, startZ + 1)) startDir = Math.PI; 
                else if (isPath(startX - 1, startZ)) startDir = Math.PI/2; 
                else if (isPath(startX + 1, startZ)) startDir = -Math.PI/2; 

                this.player.dir = startDir;

                GFX.build(this.map, this.w, this.h);
                document.querySelectorAll('.ui-screen').forEach(e => e.classList.add('hidden'));
                document.getElementById('screen-game').classList.remove('hidden');
                document.getElementById('screen-game').classList.add('flex');
                
                this.is2D = false;
                this.isThirdPerson = false;
                GFX.snapCamera = true;
                
                this.running=true;
                Timer.start(); 
                this.lastTime = Date.now();
                this.updateUI();
            },
            toggleDimension() { 
                this.is2D = !this.is2D;
                if (!this.is2D) GFX.snapCamera = true;
                this.updateUI(); 
            },
            toggleCamera() {
                if(this.is2D) return;
                this.isThirdPerson = !this.isThirdPerson;
                GFX.snapCamera = true;
                this.updateUI();
            },
            updateUI() {
                const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                
                document.getElementById('c3d').style.display = !this.is2D ? 'block' : 'none';
                document.getElementById('c2d').style.display = this.is2D ? 'block' : 'none';
                document.getElementById('minimap-wrapper').style.display = !this.is2D ? 'block' : 'none';
                
                const dict = Lang.data[Lang.current];
                const dimIcon = this.is2D ? 'ph-cube' : 'ph-map-trifold';
                const dimText = this.is2D ? dict.view_3d : dict.view_2d;
                document.getElementById('icon-dim').className = `ph ${dimIcon} text-lg`;
                document.getElementById('lbl-dim').innerText = dimText;

                const povBtn = document.getElementById('btn-pov');
                if (this.is2D) {
                    povBtn.classList.add('opacity-50', 'grayscale');
                    povBtn.classList.remove('active:scale-95');
                } else {
                    povBtn.classList.remove('opacity-50', 'grayscale');
                    povBtn.classList.add('active:scale-95');
                }
                const povIcon = this.isThirdPerson ? 'ph-eye' : 'ph-person';
                const povText = this.isThirdPerson ? dict.view_1st : dict.view_3rd;
                document.getElementById('icon-pov').className = `ph ${povIcon} text-lg`;
                document.getElementById('lbl-pov').innerText = povText;
                
                document.getElementById('controls-ui').style.display = isMobile ? 'block' : 'none';
            },
            loop() {
                requestAnimationFrame(()=>this.loop());
                if(!this.running) return;
                
                // --- DELTA TIME CALCULATION ---
                const now = Date.now();
                // Calculate time in seconds (max 0.1s to prevent huge jumps if lag occurs)
                const dt = Math.min((now - this.lastTime) / 1000, 0.1); 
                this.lastTime = now;
                // -----------------------------

                const input = Input.get(!this.is2D);
                
                if(!this.is2D) {
                    // Multiply rotation by dt
                    this.player.dir += input.rot * CONST.ROT_SPEED * dt;
                    
                    if(Math.abs(input.dz) > 0.05) {
                        // Multiply speed by dt
                        const speed = input.dz * CONST.SPEED_3D * dt;
                        const dx = -Math.sin(this.player.dir) * speed;
                        const dz = -Math.cos(this.player.dir) * speed;
                        this.move(dx, dz);
                        
                        if(now - this.stepTimer > 400) {
                            Sfx.step();
                            this.stepTimer = now;
                        }
                    }
                } else {
                    if(Math.abs(input.dx)>0.05 || Math.abs(input.dz)>0.05) {
                        // Multiply speed by dt
                        const dx = input.dx * CONST.SPEED_2D * dt;
                        const dz = input.dz * CONST.SPEED_2D * dt;
                        this.move(dx, dz);
                        if(dx!==0 || dz!==0) this.player.dir = Math.atan2(dx, -dz);
                    }
                }
                
                // ... rest of the function remains the same ...
                const gx=Math.floor(this.player.x), gz=Math.floor(this.player.z);
                if(this.map[gz][gx]===CONST.END) {
                    // ... win condition code ...
                    this.running=false;
                    const finalTime = Timer.stop();
                    document.getElementById('victory-time').innerText = finalTime;
                    document.getElementById('screen-victory').classList.remove('hidden');
                    document.getElementById('screen-victory').classList.add('flex');
                    document.getElementById('minimap-wrapper').style.display='none';
                    document.getElementById('controls-ui').style.display='none';
                    Sfx.win();
                }
                if(!this.is2D) { 
                    GFX.render(this.player, this.is2D, this.isThirdPerson); 
                    GFX.render2D(this.map, this.w, this.h, this.player, 'minimap'); 
                } else {
                    GFX.render2D(this.map, this.w, this.h, this.player, 'c2d');
                }
            },
            // --- UPDATED PHYSICS MOVE ---
            move(dx, dz) {
                // Independent axis check for sliding
                let nextX = this.player.x + dx;
                let nextZ = this.player.z + dz;

                // 1. Try X movement
                if (!this.col(nextX, this.player.z)) {
                    this.player.x = nextX;
                } else {
                    // Wall Slide/Corner Assist: If blocked on X, check if we are near a corner on Z
                    // This helps round corners smoothly if the player is slightly misaligned
                    // Only apply if NOT trying to move Z this frame (pure rotation or slight drift)
                    if (Math.abs(dz) < 0.01) {
                         const gridZ = Math.floor(this.player.z);
                         const distToTop = this.player.z - gridZ;
                         const distToBottom = (gridZ + 1) - this.player.z;
                         
                         // If very close to top edge and top neighbor is open, nudge up
                         if (distToTop < 0.3 && !this.col(nextX, gridZ - 0.5)) {
                             this.player.z -= 0.05;
                         }
                         // If very close to bottom edge and bottom neighbor is open, nudge down
                         if (distToBottom < 0.3 && !this.col(nextX, gridZ + 1.5)) {
                             this.player.z += 0.05;
                         }
                    }
                }

                // 2. Try Z movement
                if (!this.col(this.player.x, nextZ)) {
                    this.player.z = nextZ;
                } else {
                     // Same corner assist for Z blocked
                     if (Math.abs(dx) < 0.01) {
                         const gridX = Math.floor(this.player.x);
                         const distToLeft = this.player.x - gridX;
                         const distToRight = (gridX + 1) - this.player.x;
                         
                         if (distToLeft < 0.3 && !this.col(gridX - 0.5, nextZ)) {
                             this.player.x -= 0.05;
                         }
                         if (distToRight < 0.3 && !this.col(gridX + 1.5, nextZ)) {
                             this.player.x += 0.05;
                         }
                     }
                }
                
                // 3. Resolve overlap (Emergency push out)
                if (this.col(this.player.x, this.player.z)) {
                     // Push back towards center of current cell
                     const cx = Math.floor(this.player.x) + 0.5;
                     const cz = Math.floor(this.player.z) + 0.5;
                     this.player.x += (cx - this.player.x) * 0.1;
                     this.player.z += (cz - this.player.z) * 0.1;
                }
            },
            col(x, z) {
                const r = CONST.COLLISION_RADIUS;
                // Check all 4 corners of the bounding box
                const points = [
                    {x: x-r, z: z-r}, {x: x+r, z: z-r},
                    {x: x-r, z: z+r}, {x: x+r, z: z+r}
                ];
                
                for(let p of points) {
                    const cx = Math.floor(p.x);
                    const cz = Math.floor(p.z);
                    
                    if(cx < 0 || cx >= this.w || cz < 0 || cz >= this.h) return true;
                    if(this.map[cz][cx] === CONST.WALL) return true;
                }
                return false;
            },
            quit() {
                this.running=false; Timer.reset();
                document.querySelectorAll('.ui-screen').forEach(e => e.classList.add('hidden'));
                document.getElementById('screen-menu').classList.remove('hidden');
                document.getElementById('minimap-wrapper').style.display='none';
                document.getElementById('controls-ui').style.display='none';
            }
        };

        const Editor = {
            grid: [], size: 10, tool: 1, isDrawing: false, zoom: 1.0, mode: 'draw',
            open() {
                if(this.grid.length === 0) this.resize(this.size);
                document.getElementById('screen-menu').classList.add('hidden');
                document.getElementById('screen-editor').classList.remove('hidden');
                document.getElementById('screen-editor').classList.add('flex');
                setTimeout(()=>this.render(), 10);
                const vp = document.getElementById('editor-grid');
                const handleStart = (e) => {
                    if(this.mode === 'pan') return; 
                    e.preventDefault();
                    this.isDrawing = true; this.handleInput(e);
                    vp.setPointerCapture(e.pointerId);
                };
                const handleMove = (e) => {
                    if(this.mode === 'pan') return;
                    e.preventDefault();
                    if(this.isDrawing) this.handleInput(e);
                };
                vp.onpointerdown = handleStart; vp.onpointermove = handleMove; vp.onpointerup = () => this.isDrawing = false;
            },
            close() {
                document.getElementById('screen-editor').classList.add('hidden');
                document.getElementById('screen-menu').classList.remove('hidden');
            },
            generateFromCode() {
                const code = document.getElementById('ed-code').value.trim();
                const size = parseInt(document.getElementById('ed-size').value);
                if(!code) return alert("Please enter a code");
                Seed.set(code.toUpperCase());
                this.grid = MazeGen.generate(size, size, Seed.rng);
                this.size = size;
                document.getElementById('lbl-size').innerText = `${this.size}x`;
                Seed.reset(); this.render();
            },
            setTool(t) { this.tool = t; this.updateUI(); },
            setMode(m) { 
                this.mode = m; 
                document.getElementById('editor-viewport').className = `flex-1 bg-grid-pattern relative p-4 md:p-8 mode-${m} overflow-hidden flex items-center justify-center`;
                this.updateUI();
            },
            updateUI() {
                document.querySelectorAll('.tool-btn').forEach(b => {
                    b.classList.remove('border-cyan-400', 'bg-slate-700');
                    b.classList.add('bg-slate-800', 'border-transparent');
                    b.querySelector('span').classList.remove('text-white');
                    b.querySelector('span').classList.add('text-slate-400');
                });
                
                const activeBtn = document.getElementById('t-'+this.tool);
                activeBtn.classList.remove('bg-slate-800', 'border-transparent');
                activeBtn.classList.add('bg-slate-700', 'border-cyan-400');
                activeBtn.querySelector('span').classList.remove('text-slate-400');
                activeBtn.querySelector('span').classList.add('text-white');

                const drawBtn = document.getElementById('btn-mode-draw');
                const panBtn = document.getElementById('btn-mode-pan');
                
                if(this.mode === 'draw') {
                    drawBtn.classList.add('bg-cyan-700', 'text-white');
                    drawBtn.classList.remove('text-slate-400', 'hover:text-white');
                    panBtn.classList.remove('bg-cyan-700', 'text-white');
                    panBtn.classList.add('text-slate-400', 'hover:text-white');
                } else {
                    panBtn.classList.add('bg-cyan-700', 'text-white');
                    panBtn.classList.remove('text-slate-400', 'hover:text-white');
                    drawBtn.classList.remove('bg-cyan-700', 'text-white');
                    drawBtn.classList.add('text-slate-400', 'hover:text-white');
                }
            },
            resize(v) { 
                this.size = parseInt(v); 
                document.getElementById('lbl-size').innerText = `${this.size}x`; 
                this.grid = Array(this.size).fill().map((_,y)=>Array(this.size).fill().map((_,x)=>(x===0||y===0||x===this.size-1||y===this.size-1)?1:0));
                this.render(); 
            },
            setZoom(v) { this.zoom = parseFloat(v); this.render(); },
            clear() { this.resize(this.size); },
            handleInput(e) {
                const el = document.elementFromPoint(e.clientX, e.clientY);
                if(el && el.dataset.x) this.paint(parseInt(el.dataset.x), parseInt(el.dataset.y), el);
            },
            paint(x, y, el) {
                if(this.tool===2||this.tool===3) {
                    this.grid.forEach((r,ry)=>r.forEach((_,rx)=>{ if(this.grid[ry][rx]===this.tool) { this.grid[ry][rx]=0; this.updateCell(rx,ry,0); } }));
                }
                this.grid[y][x] = this.tool;
                el.className = `grid-cell ${this.getClass(this.tool)}`;
            },
            updateCell(x, y, type) {
                const idx = y*this.size + x;
                const gridEl = document.getElementById('editor-grid');
                if(gridEl.children[idx]) gridEl.children[idx].className = `grid-cell ${this.getClass(type)}`;
            },
            getClass(t) { return t===1?'c-wall':t===3?'c-end':t===2?'c-start':'c-path'; },
            render() {
                const el = document.getElementById('editor-grid');
                const viewport = document.getElementById('editor-viewport');
                el.innerHTML = '';
                // No complex calc needed due to flex centering, just render grid
                const cellSize = Math.floor(16 * this.zoom); // Base 16px * zoom
                
                el.style.gridTemplateColumns = `repeat(${this.size}, ${cellSize}px)`;
                el.style.width = 'fit-content'; 
                const frag = document.createDocumentFragment();
                for(let y=0; y<this.size; y++) for(let x=0; x<this.size; x++) {
                    const d = document.createElement('div');
                    d.style.width = `${cellSize}px`;
                    d.style.height = `${cellSize}px`;
                    d.className = `grid-cell ${this.getClass(this.grid[y][x])}`;
                    d.dataset.x = x; d.dataset.y = y;
                    frag.appendChild(d);
                }
                el.appendChild(frag);
            }
        };

        window.onload = () => Game.init();
    </script>
</body>
</html>
